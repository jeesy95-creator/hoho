# 프로그래머스 Lv2 250136 - 석유 시추

🔗 문제 링크
https://school.programmers.co.kr/learn/courses/30/lessons/250136

---

## 문제 설명
세로 n, 가로 m인 격자에서 석유 덩어리를 찾고, 시추관 하나를 수직으로 설치해서 가장 많은 석유를 뽑을 수 있는 위치를 찾는 문제입니다.

### 핵심 요구사항
- 시추관은 하나의 열을 관통
- 시추관이 지나는 석유 덩어리의 전체를 획득
- 상하좌우로 연결된 석유는 하나의 덩어리

## 접근 방법

### 1. BFS로 석유 덩어리 탐색
- 모든 칸을 순회하며 아직 방문하지 않은 석유 발견
- BFS로 연결된 석유 덩어리 탐색
- 각 덩어리에 고유 ID 부여

### 2. 각 덩어리 정보 저장
- `oil_size`: 각 덩어리의 크기 저장
- `oil_id`: 각 위치가 어느 덩어리에 속하는지 저장

### 3. 열별 석유량 계산
- 각 열마다 지나는 덩어리들을 set으로 수집 (중복 제거)
- 해당 덩어리들의 크기 합산
- 최댓값 반환

## 시간 복잡도
- BFS: O(n × m) - 모든 칸을 한 번씩 방문
- 열별 계산: O(m × n) - 각 열마다 모든 행 확인
- **전체: O(n × m)**

## 핵심 아이디어

### 1. oil_id 배열 사용
각 위치에 덩어리 번호를 저장하여, 열별 계산 시 효율적으로 처리
```python
oil_id = [[-1] * m for _ in range(n)]
# -1: 빈 땅, 0~: 덩어리 번호
```

### 2. 효율성을 위한 설계
- 각 열마다 n개 행만 확인 → O(n)
- 덩어리 개수와 무관하게 일정한 시간

## 배운 점
1. **BFS 활용**: 연결된 영역 탐색
2. **deque 사용**: 효율적인 큐 구현 (O(1) popleft)
3. **set 활용**: 중복 제거
4. **효율성의 중요성**: 같은 정답이라도 시간 복잡도에 따라 통과 여부가 결정됨

## 다른 접근 방법과 비교
- **oil_info 방식**: 각 덩어리마다 (크기, 지나는 열) 저장
  - 장점: 직관적
  - 단점: 열별 계산 시 모든 덩어리 확인 필요 → 덩어리가 많으면 느림
  
- **oil_id 방식** (채택): 각 위치에 덩어리 번호 저장
  - 장점: 열별 계산이 O(n)으로 고정
  - 단점: 약간 더 복잡한 구조

## 제출 결과
- 정확성 테스트: 통과
- 효율성 테스트: 통과


## 세 가지 접근 방식 비교

| 방식 | 시간 복잡도 | 공간 복잡도 | 효율성 테스트 | 가독성 |
|------|------------|------------|--------------|--------|
| oil_info | O(m × 덩어리수) | O(덩어리수) | ❌ 실패 | ⭐⭐⭐ 높음 |
| oil_id (채택) | O(n × m) | O(n × m) | ✅ 통과 | ⭐⭐ 보통 |
| col_mapping | O(n × m) | O(덩어리수 × 열수) | ✅ 통과 | ⭐⭐ 보통 |

### 방식별 특징

#### 1. oil_info 방식
- **장점**: 가장 직관적이고 이해하기 쉬움
- **단점**: 열별 계산 시 모든 덩어리를 순회해야 하므로 비효율적
- **적합한 경우**: 정확성 테스트만 통과하면 되는 경우

#### 2. oil_id 방식 (최종 채택)
- **장점**: 각 위치에 덩어리 번호를 저장하여 열별 계산이 O(n)으로 고정
- **단점**: 2차원 배열 추가 필요
- **적합한 경우**: 효율성이 중요한 경우

#### 3. col_mapping 방식
- **장점**: BFS 중 바로 열-덩어리 매핑 구축, 열별 계산 빠름
- **단점**: defaultdict 등 추가 자료구조 필요
- **적합한 경우**: 메모리 효율과 속도 모두 고려할 때